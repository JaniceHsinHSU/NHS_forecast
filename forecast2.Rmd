---
title: "Hierarchical_2"
author: "Janice Hsu"
date: "2023-09-15"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
```


```{r}
data <- read.csv("HLTH0037_ts_cleaned.csv")
```


```{r}
data <- data %>%
  mutate(YearMonth = yearmonth(YearMonth)) %>%
  as_tsibble(index = YearMonth, key = c(Age_Code, Sex_ItemName_ENG, Hospital_Code, Hospital_ItemName_ENG)) 

```

#Number of patients entering ED under different hospital hierarchy
```{r}

data_hts <- data %>%
  aggregate_key(Organisation/Hospital_ItemName_ENG, Number = sum(Data))
  
data_hts |>
  filter(is_aggregated(Hospital_ItemName_ENG)) |>
  autoplot(Number) +
  labs(y = "Number of patients",
       title = "Number of patients who enter ED") +
  facet_wrap(vars(Organisation), scales = "free_y", ncol = 3) +
  theme(legend.position = "none")+
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text.y = element_text(angle = 0, hjust = 1)) 
```

•	A couple of Local Health Boards (LHBs) were redefined from the 1st of April 2019 onwards: Cwm Taf (27)--> Cwm Taf Morgannwg (30)// Abertawe Bro Morgannwg (26) --> Swansea Bay (31). Therefore, if you decide to forecast at LHB resolution, you might want to consider these 4 as a unique one. 
•	A the Princess of Wales Hospital changed its Local Health Boards
•	So we analyse these 4 as one organisation

# Group the changed Local Health Board together

```{r}

data_grouped <- data %>%
  mutate(Aggregated_Organisation = case_when(
    Organisation %in% c("Cwm Taf", "Cwm Taf Morgannwg", "Abertawe Bro Morgannwg", "Swansea Bay") ~ "Grouped_4_organisation",
    TRUE ~ Organisation
  ))

```

# There are 6 Local Health Boards
```{r}
unique(data_grouped$Aggregated_Organisation)
```

```{r}
data2_hts <- data_grouped %>%
  group_by(Aggregated_Organisation) %>%
  summarise(Number = sum(Data))
```

# Number of patients who enter ED under 6 different local health boards
```{r}
data2_hts |>
  ggplot(aes(x = YearMonth, y = Number)) +
  geom_line(stat = "identity") +
  labs(y = "Number of patients",
       title = "Number of patients who enter ED") +
  facet_wrap(vars(Aggregated_Organisation), scales = "free_y", ncol = 3) +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


# Change the Age_Code structure into different groups

```{r}
unique(data_grouped$Age_Code)
```


# Age group: "0-4", "5-17", "18-69", "70^"
```{r}
data_grouped_age <- data_grouped %>%
  filter(Age_Code != "Unknown") %>%
  mutate(Grouped_Age = case_when(
    Age_Code == "0 to 4" ~ "0-4",
    Age_Code == "5 to 17" ~ "5-17",
    Age_Code %in% c("18 to 24", "25 to 29", "30 to 34", "35 to 39", 
                    "40 to 44", "45 to 49", "50 to 54", "55 to 59", 
                    "60 to 64", "65 to 69") ~ "18-69",
    Age_Code %in% c("70 to 74", "75 to 79", "80 to 84", "85") ~ "70 and over",
    TRUE ~ "Other"
  ))

```


# Plot Number of Patients in different age groups
```{r}
data_gts <- data_grouped_age %>%
  filter(Sex_ItemName_ENG != "Not Specified or invalid") %>%
  group_by(Grouped_Age, Sex_ItemName_ENG) %>%
  summarize(Number = sum(Data, na.rm = TRUE))

ggplot(data_gts, aes(x = Grouped_Age, y = Number)) +
  geom_bar(stat = "identity") +
  labs(y = "Number of patients") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~ Sex_ItemName_ENG, scales = "free")


```


#Change the data into wide format

```{r}

data2_wide <- data_grouped %>%
  group_by(Aggregated_Organisation) %>%
  index_by(YearMonth) %>%
  summarise(Number = sum(Data)) %>%
  pivot_wider(names_from = Aggregated_Organisation, values_from = Number)


```

```{r}
data2_wide <- as_tibble(data2_wide)
data2_wide <- data2_wide %>%
   mutate(Total = rowSums(select(., c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching")), na.rm = TRUE))

```





```{r}
library(forecast)

# Convert data into time series
start_year <- year(min(data2_wide$YearMonth))
start_month <- month(min(data2_wide$YearMonth))

# Convert each column to a ts object
cols_to_forecast <- c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching", "Total")
forecast_list <- list()

for (col in cols_to_forecast) {
  ts_data <- ts(data2_wide[[col]], start = c(start_year, start_month), frequency = 12)
  
  # Forecast using auto.arima
  forecast_model <- auto.arima(ts_data)
  forecast_list[[col]] <- forecast(forecast_model, h = 6)
}

```

```{r}
print(forecast_list)

```

```{r}
for (col in cols_to_forecast) {
  print(autoplot(forecast_list[[col]]) + ggtitle(paste("Forecast for", col)))
}

```


# Accuracy

```{r}

h_forecast <- 12 
h_validate <- 6

# Splitting data
training_data <- head(data2_wide, nrow(data2_wide) - h_validate)
test_data <- tail(data2_wide, h_validate)


```



# Forecast

```{r}
# Define the forecast horizon and validation period
h <- 12
validation_period <- 6

# Splitting the data
training_data <- head(data2_wide, nrow(data2_wide) - validation_period)
test_data <- tail(data2_wide, validation_period)

# Forecasting
forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))

for (col in cols_to_forecast) {
  ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
  forecast_model <- auto.arima(ts_data)
  forecast_list[[col]] <- forecast(forecast_model, h = h)
}

# Plotting
for (col in cols_to_forecast) {
  end_year_train <- year(max(training_data$YearMonth))
  end_month_train <- month(max(training_data$YearMonth))
  
  start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
  start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
  
  actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
  
  plot_forecast <- autoplot(forecast_list[[col]]) +
    autolayer(actual_ts, series="Actual", PI=FALSE) +
    labs(title = paste("Forecast vs Actual for", col)) +
    theme(legend.position = "bottom")
  
  print(plot_forecast)
}

# Error Metrics
error_metrics <- list()

for (col in cols_to_forecast) {
  actual <- test_data[[col]]
  forecasted <- head(forecast_list[[col]]$mean, validation_period)  # Taking just the first 6 months of forecast
  
  MAE <- mae(actual, forecasted)
  RMSE <- rmse(actual, forecasted)
  MAPE <- tryCatch(mape(actual, forecasted), error = function(e) NA)  # Handle potential errors due to division by zero
  
  error_metrics[[col]] <- list(MAE = MAE, RMSE = RMSE, MAPE = MAPE)
}

print(error_metrics)

```








