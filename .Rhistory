rep("Betsi Cadwaladr", 5)),
to = c("Betsi Cadwaladr", "Hywel Dda", "Grouped_4_organisation",
"Cardiff & Vale", "Aneurin Bevan", "Powys Teaching",
"Ysbyty Glan Clwyd", "Wrexham Maelor Hospital", "Colwyn Bay Community Hospital",
"Holywell Community Hospital", "Mold Community Hospital"),
stringsAsFactors = FALSE
)
# Creating graph object
graph <- graph_from_data_frame(d = edges_df, vertices = nodes_df, directed = TRUE)
# Creating the plot using ggraph
ggraph(graph, layout = "tree") +
geom_edge_link() +
geom_node_point() +
geom_node_text(aes(label = name), angle = 45, hjust = 1, vjust = 1.5) +
theme_void()
fit_age <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() , link = "log", model = list(past_obs = 1:3))
)|> mutate (comb = (naive_model+ets_model+tscount)/3))
fit_age <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() , link = "log", model = list(past_obs = 1:3))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)
View(fit_age)
fc_age <- fit_age %>%
select("comb") %>%
reconcile(bu = bottom_up(base)) %>%
forecast()
fc_age <- fit_age %>%
select("comb") %>%
reconcile(bu = bottom_up(comb)) %>%
forecast()
fc_age <- fit_age %>%
select("comb") %>%
reconcile(bu = bottom_up(comb)) %>%
forecast(h=18)
View(fc_age)
# Filter the forecast results for aggregated levels and plot
fc_age %>%
filter(is_aggregated(Aggregated_Organisation), !is_aggregated(Grouped_Age)) %>%
autoplot(
data_full %>% filter(yearmonth(YearMonth) >= yearmonth("2020 Jan")),level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Grouped_Age), scales = "free_y") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
# The reconciliation didn't work
fc_age <- fit_age %>%
select("comb") %>%
reconcile(bu = bottom_up(comb),
wls_ETS1 = min_trace(comb, method = "wls_struct"),
wls_ETS2 = min_trace(comb, method = "wls_var"),
mint_ETS = min_trace(comb, method = "mint_shrink")) %>%
forecast(h=18)
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
library(purrr)
library(tidyr)
library(stats)
library(fable)
library(dplyr)
library(igraph)
library(ggraph)
# Nodes data
nodes_df <- data.frame(
name = c("All Wales",
"Betsi Cadwaladr", "Hywel Dda", "Grouped_4_organisation",
"Cardiff & Vale", "Aneurin Bevan", "Powys Teaching",
"Ysbyty Glan Clwyd", "Wrexham Maelor Hospital", "Colwyn Bay Community Hospital",
"Holywell Community Hospital", "Mold Community Hospital"),
stringsAsFactors = FALSE
)
# Edges data
edges_df <- data.frame(
from = c(rep("All Wales", 6),
rep("Betsi Cadwaladr", 5)),
to = c("Betsi Cadwaladr", "Hywel Dda", "Grouped_4_organisation",
"Cardiff & Vale", "Aneurin Bevan", "Powys Teaching",
"Ysbyty Glan Clwyd", "Wrexham Maelor Hospital", "Colwyn Bay Community Hospital",
"Holywell Community Hospital", "Mold Community Hospital"),
stringsAsFactors = FALSE
)
# Creating graph object
graph <- graph_from_data_frame(d = edges_df, vertices = nodes_df, directed = TRUE)
# Creating the plot using ggraph
ggraph(graph, layout = "tree") +
geom_edge_link() +
geom_node_point() +
geom_node_text(aes(label = name), angle = 45, hjust = 1, vjust = 1.5) +
theme_void()
library(igraph)
# Nodes data
nodes_df <- data.frame(
name = c("All Wales",
"Betsi Cadwaladr", "Hywel Dda", "Grouped_4_organisation",
"Cardiff & Vale", "Aneurin Bevan", "Powys Teaching",
"Ysbyty Glan Clwyd", "Wrexham Maelor Hospital", "Colwyn Bay Community Hospital",
"Holywell Community Hospital", "Mold Community Hospital"),
stringsAsFactors = FALSE
)
# Edges data
edges_df <- data.frame(
from = c(rep("All Wales", 6),
rep("Betsi Cadwaladr", 5)),
to = c("Betsi Cadwaladr", "Hywel Dda", "Grouped_4_organisation",
"Cardiff & Vale", "Aneurin Bevan", "Powys Teaching",
"Ysbyty Glan Clwyd", "Wrexham Maelor Hospital", "Colwyn Bay Community Hospital",
"Holywell Community Hospital", "Mold Community Hospital"),
stringsAsFactors = FALSE
)
# Creating graph object
graph <- graph_from_data_frame(d = edges_df, vertices = nodes_df, directed = TRUE)
# Color vector: 1 color for "All Wales", 6 colors for organisations, and 5 colors for hospitals
vertex_colors <- c("skyblue", rep("lightgreen", 6), rep("lightpink", 5))
# Plot the graph
plot(graph,
vertex.size = 15,
vertex.label.cex = 0.6,
vertex.color = vertex_colors,
edge.arrow.size = 0.5,
vertex.label.degree = pi/4, # 45-degree label rotation
layout = layout.reingold.tilford(graph, root = 1))
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
library(purrr)
library(tidyr)
library(stats)
library(fable)
library(dplyr)
library(igraph)
library(ggraph)
data <- read.csv("HLTH0037_ts_cleaned.csv")
# change data structure
data <- data %>%
mutate(YearMonth = yearmonth(YearMonth)) %>%
as_tsibble(index = YearMonth, key = c(Age_Code, Sex_ItemName_ENG, Hospital_Code, Hospital_ItemName_ENG))
# The reconciliation didn't work
fc_age <- fit_age %>%
select("comb") %>%
reconcile(bu = bottom_up(comb)) %>%
forecast(h=18)
View(fc_age)
install.packages("patchwork")
library(patchwork)
plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
plots[[col]] <- plot_forecast
}
# Combine all plots into a single plot object using patchwork
combined_plot <- wrap_plots(plots, ncol = 1)
# Print the combined plot
print(combined_plot)
plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
plots[[col]] <- plot_forecast
}
# Combine all plots into a single plot object using patchwork
combined_plot <- wrap_plots(plots)
# Print the combined plot
print(combined_plot)
plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
# Create a plot
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
# Print each plot on a new slide
print(xaringan::moon_reader("----"))
print(plot_forecast)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
# Dynamically create a slide
cat("----\n")
# Slide title
cat("### Forecast vs Actual for", col, "\n")
# Insert an R chunk to generate the plot
cat("```{r, echo=FALSE, fig.width=8, fig.height=5}\n")
cat("autoplot(forecast_list[['", col, "']]) + \n")
cat("  autolayer(actual_ts, series='Actual', PI=FALSE) + \n")
cat("  labs(title = paste('Forecast vs Actual for', '", col, "')) + \n")
cat("  theme(legend.position = 'bottom')\n")
cat("```\n")
}
autoplot(forecast_list[[' Aneurin Bevan ']]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', ' Aneurin Bevan ')) +
theme(legend.position = 'bottom')
autoplot(forecast_list[[' Aneurin Bevan ']]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', ' Aneurin Bevan ')) +
theme(legend.position = 'bottom')
autoplot(forecast_list[[' Aneurin Bevan ']]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', ' Aneurin Bevan ')) +
theme(legend.position = 'bottom')
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
library(purrr)
library(tidyr)
library(stats)
library(fable)
library(dplyr)
library(igraph)
library(ggraph)
library(patchwork)
autoplot(forecast_list[[' Aneurin Bevan ']]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', ' Aneurin Bevan ')) +
theme(legend.position = 'bottom')
library(purrr)
# assuming plots is a list of ggplot objects
plots <- lapply(cols_to_forecast, function(col) {
autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
})
map(plots, print)
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
# Dynamically create a slide
cat("----\n")
# Slide title
cat("### Forecast vs Actual for", col, "\n")
# Insert an R chunk to generate the plot
cat("```{r, echo=FALSE, fig.width=8, fig.height=5}\n")
cat("autoplot(forecast_list[['", col, "']]) + \n")
cat("  autolayer(actual_ts, series='Actual', PI=FALSE) + \n")
cat("  labs(title = paste('Forecast vs Actual for', '", col, "')) + \n")
cat("  theme(legend.position = 'bottom')\n")
cat("```\n")
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
# Dynamically create a slide
cat("----\n")
# Slide title
cat("### Forecast vs Actual for", col, "\n")
# Insert an R chunk to generate the plot
cat("```{r, echo=FALSE, fig.width=8, fig.height=5}\n")
cat("autoplot(forecast_list[['", col, "']]) + \n")
cat("  autolayer(actual_ts, series='Actual', PI=FALSE) + \n")
cat("  labs(title = paste('Forecast vs Actual for', '", col, "')) + \n")
cat("  theme(legend.position = 'bottom')\n")
cat("```\n")
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
p <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
plots[[col]] <- p
}
for (col in names(plots)) {
cat("----\n")
cat("### Forecast vs Actual for", col, "\n")
print(plots[[col]])
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
p <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
plots[[col]] <- p
}
for (col in names(plots)) {
cat("----\n")
cat("### Forecast vs Actual for", col, "\n")
print(plots[[col]])
}
print(plots[['FirstColumnName']])
print(plots[['Aneurin Bevan']])
library(gridExtra)
plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
p <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
plots[[col]] <- p
}
gridExtra::grid.arrange(grobs = plots, ncol = 2) # Adjust ncol as needed
gridExtra::grid.arrange(grobs = plots, ncol = 1) # Adjust ncol as needed
gridExtra::grid.arrange(grobs = plots, ncol = 2) # Adjust ncol as needed
plots[[col]] <- p
plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
p <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
plots[[col]] <- p
}
ets_plots <- list()
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
p <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series='Actual', PI=FALSE) +
labs(title = paste('Forecast vs Actual for', col)) +
theme(legend.position = 'bottom')
ets_plots[[col]] <- p
}
unique(data_grouped$Aggregated_Organisation)
joined_data <- as_tibble(test_data) %>%
left_join(as_tibble(fc_cv), by = c("YearMonth", "Aggregated_Organisation")) %>%
select(-attendance.y) %>%
rename(attendance = attendance.x) %>%
rename(forecast = .mean)
# Generate forecasts
fc_cv <- fit_cv %>%
forecast(h = 12) %>%
filter(.model == "comb")
# Generate forecasts for aggregated
fc_cv_filtered <- fit_cv %>%
forecast(h = 12) %>%
filter(.model == "comb") %>%
filter(Aggregated_Organisation == "<aggregated>")
# Check the accuracy
forecasted_values <- fc_cv_filtered$.mean
accuracy_value <- accuracy(
as.data.frame(forecasted_values),as.data.frame(test_data_filtered$attendance))
print(accuracy_value)
joined_data <- as_tibble(test_data) %>%
left_join(as_tibble(fc_cv), by = c("YearMonth", "Aggregated_Organisation")) %>%
select(-attendance.y) %>%
rename(attendance = attendance.x) %>%
rename(forecast = .mean)
fc_cv
joined_data <- as_tibble(test_data) %>%
left_join(as_tibble(fc_cv), by = c("YearMonth", "Aggregated_Organisation")) %>%
select(-attendance.y) %>%
rename(attendance = attendance.x) %>%
rename(forecast = .mean)
test_data
data_wales
library(tscount)
# Split data
training_data <- data_wales %>%
filter(YearMonth <= yearmonth("2022 Jun"))
test_data <- data_wales %>%
filter(YearMonth > yearmonth("2022 Jun"))
test_data_filtered <- test_data %>%
filter(Aggregated_Organisation == "<aggregated>")
# average the three models
library(fable.tscount)
fit_cv<- training_data %>%
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() , link = "log", model = list(past_obs = 1:3))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)
# Generate forecasts
fc_cv <- fit_cv %>%
forecast(h = 12) %>%
filter(.model == "comb")
# Generate forecasts for aggregated
fc_cv_filtered <- fit_cv %>%
forecast(h = 12) %>%
filter(.model == "comb") %>%
filter(Aggregated_Organisation == "<aggregated>")
# Check the accuracy
forecasted_values <- fc_cv_filtered$.mean
accuracy_value <- accuracy(
as.data.frame(forecasted_values),as.data.frame(test_data_filtered$attendance))
print(accuracy_value)
joined_data <- as_tibble(test_data) %>%
left_join(as_tibble(fc_cv), by = c("YearMonth", "Aggregated_Organisation")) %>%
select(-attendance.y) %>%
rename(attendance = attendance.x) %>%
rename(forecast = .mean)
joined_data <- as_tibble(test_data) %>%
left_join(as_tibble(fc_cv), by = c("YearMonth", "Aggregated_Organisation")) %>%
select(-attendance.y) %>%
rename(attendance = attendance.x) %>%
rename(forecast = .mean)
comparison_data <- data.frame(
Month = yearmonth(test_data$YearMonth),
Actual = test_data$attendance,
Forecasted = fc_cv$.mean,
Aggregated_Organisation = test_data$Aggregated_Organisation
) %>%rowwise()
joined_data_long<- joined_data %>%
pivot_longer(
cols = c(attendance, forecast),
names_to = "Type",
values_to = "Value"
)
unique_organisations <- unique(joined_data_long$Aggregated_Organisation)
plot_list <- map(unique_organisations, ~{
ggplot(joined_data_long[joined_data_long$Aggregated_Organisation == .x,],
aes(x = YearMonth, y = Value, color = Type)) +
geom_line() +
labs(title = paste("Forecasted vs Actual Values for", .x),
y = "Values") +
theme_minimal()
})
print(plot_list)
print(plot_list[['<aggregated>']])
joined_data_long<- joined_data %>%
pivot_longer(
cols = c(attendance, forecast),
names_to = "Type",
values_to = "Value"
)
unique_organisations <- unique(joined_data_long$Aggregated_Organisation)
plot_list <- map(unique_organisations, ~{
ggplot(joined_data_long[joined_data_long$Aggregated_Organisation == .x,],
aes(x = YearMonth, y = Value, color = Type)) +
geom_line() +
labs(title = paste("Forecasted vs Actual Values for", .x),
y = "Values") +
theme_minimal()
})
plot_list[[1]]
