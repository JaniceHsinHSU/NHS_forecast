data_hts <- data_grouped_age |>
aggregate_key((Aggregated_Organisation / Hospital_ItemName_ENG) * Grouped_Age, attendance = sum(Data))
data_hts <- data_hts %>%
as_tsibble(key = c("Aggregated_Organisation", "Grouped_Age", "Hospital_ItemName_ENG"), index = "YearMonth")
# Split data
training_data <- data_hts %>%
filter(YearMonth <= yearmonth("2020 Jun"))
test_data <- data_hts %>%
filter(YearMonth > yearmonth("2020 Jun"))
test_data_filtered <- test_data %>%
filter(Aggregated_Organisation == "<aggregated>")
# Set up rolling-origin time series cross-validation
tscv <- training_data %>%
filter(Aggregated_Organisation == "<aggregated>") %>%
stretch_tsibble(.init = 99, .step = 1)
training_data %>%
filter(Aggregated_Organisation == "<aggregated>")
View(training_data)
training_data %>%
filter(Aggregated_Organisation == "<aggregated>")
# Set up rolling-origin time series cross-validation
tscv <- training_data %>%
filter(Aggregated_Organisation == "<aggregated>") %>%
stretch_tsibble(.init = 99, .step = 1)
# Set up rolling-origin time series cross-validation
tscv <- training_data %>%
filter(Aggregated_Organisation == "<aggregated>") %>%
stretch_tsibble(.init = 98, .step = 1)
# TSCV accuracy
tscv_forecast <- tscv |>
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() + season() , link = "log", model = list(past_obs = 1:12))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)  |>
forecast(h = 36)
View(tscv_forecast)
View(tscv_forecast)
str(tscv_forecast)
View(tscv_forecast)
# TSCV accuracy
tscv_model <- tscv |>
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() + season() , link = "log", model = list(past_obs = 1:12))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)
# Function to calculate MASE and RMSSE for a single model
calc_scaled_errors_for_model_organisation <- function(model_name, organisation) {
# Get forecasted and actual values for specific model and organisation
fc_single_model_org <- tscv_model %>%
forecast(h = 36) %>%
filter(.model == model_name, Aggregated_Organisation == organisation)
forecasted_values_single <- fc_single_model_org$.mean
actual_values_org <- test_data %>%
filter(Aggregated_Organisation == organisation) %>%
pull(attendance)
# Calculate errors
errors <- actual_values_org - forecasted_values_single
mean_abs_error <- mean(abs(errors), na.rm = TRUE)
mean_squared_error <- mean(errors^2, na.rm = TRUE)
# Calculate naive errors using direct indexing for lag
naive_forecast <- c(NA, actual_values_org[1:(length(actual_values_org) - 1)]) # Shift the series by one
naive_errors <- actual_values_org - naive_forecast
naive_forecast_error <- mean(abs(naive_errors), na.rm = TRUE) # For MASE
naive_forecast_squared_error <- mean(naive_errors^2, na.rm = TRUE) # For RMSSE
# Calculate MASE and RMSSE
MASE <- mean_abs_error / naive_forecast_error
RMSSE <- sqrt(mean_squared_error / naive_forecast_squared_error) # This is a hypothesized version of RMSSE based on MASE's concept
return(list(MASE = MASE, RMSSE = RMSSE))
}
# Specify models and organisations
models <- c("naive_model", "ets_model", "tscount", "comb")
organisations <- unique(training_data$Aggregated_Organisation)
# Nested lapply to iterate over models and organisations
results_list <- lapply(models, function(model) {
model_results <- lapply(organisations, function(org) {
calc_scaled_errors_for_model_organisation(model, org)
})
# Name each element in the list for clarity
names(model_results) <- organisations
# Include the model name in the results
return(list(
model = model,
results = model_results
))
})
# Set names for the list based on model names for clarity
names(results_list) <- models
# Define safe_extract function
safe_extract <- function(x, field) {
if (is.list(x) && !is.null(x[[field]])) {
return(x[[field]])
} else {
return(NA)
}
}
# Convert the results list to a data frame
results_df <- map_df(results_list, ~{
if (is.list(.x$results)) {
map_df(.x$results, ~{
tibble(
organisation = names(.x),
MASE = safe_extract(.x, "MASE"),
RMSSE = safe_extract(.x, "RMSSE")
)
}, .id = "model")
} else {
return(tibble(organisation = NA, MASE = NA, RMSSE = NA, model = NA))
}
}, .id = "model_name")
# Selecting relevant columns
results_df <- results_df %>%
select(model_name, model, organisation, MASE, RMSSE) %>%
filter(model == "<aggregated>")
# Print the results
print(results_df)
data_wales
tscv <- data_hts %>%
stretch_tsibble(.init = 99, .step = 1)
tscv <- training_data %>%
filter(Aggregated_Organisation == "<aggregated>") %>%
stretch_tsibble(.init = 98, .step = 1)
fit_model <- data_hts |>
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() + season() , link = "log", model = list(past_obs = 1:12))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)
wales_rc <- fit_model %>%
reconcile(bu = bottom_up(comb),
wls_ETS1 = min_trace(comb, method = "wls_struct"),
wls_ETS2 = min_trace(comb, method = "wls_var"),
mint_ETS = min_trace(comb, method = "mint_shrink")) %>%
forecast(h = 6)
wales_rc <- fit_model %>%
reconcile(bu = bottom_up(comb),
wls_ETS1 = min_trace(comb, method = "wls_struct"),
mint_ETS = min_trace(comb, method = "mint_shrink")) %>%
forecast(h = 6)
forecast(h = 6)
wales_rc <- fit_model %>%
reconcile(bu = bottom_up(comb),
wls_ETS1 = min_trace(comb, method = "wls_struct"),
mint_ETS = min_trace(comb, method = "mint_shrink")) %>%
forecast(h = 6)
wales_rc <- fit_model %>%
reconcile(bu = bottom_up(comb),
wls_ETS1 = min_trace(comb, method = "wls_struct")) %>%
forecast(h = 6)
forecast_wales_avg <- wales_rc %>%
as_tibble() %>%
group_by(Aggregated_Organisation, YearMonth) %>%
summarise(mean_attendance = mean(.mean, na.rm = TRUE), .groups = "drop")
forecast_wales_avg <- forecast_wales_avg %>%
rename(attendance = mean_attendance)
data_wales$Aggregated_Organisation <- as.factor(data_wales$Aggregated_Organisation)
data2_hts$Aggregated_Organisation <- as.factor(data2_hts$Aggregated_Organisation)
forecast_wales_avg$Aggregated_Organisation <- as.factor(forecast_wales_avg$Aggregated_Organisation)
combined_data_rc <- bind_rows(data_wales, data2_hts, forecast_wales_avg)
combined_data_rc <- combined_data_rc %>%
mutate(data_type = if_else(YearMonth < ymd("2023-06-01"), "Historical", "Forecast"))
# Plotting
ggplot(combined_data_rc, aes(x = YearMonth, y = attendance, color = data_type)) +
geom_line() +
facet_wrap(~Aggregated_Organisation, scales = "free_y") +
theme_minimal() +
labs(title = "Attendance Over Time",
subtitle = "Distinguishing between historical and forecasted data",
x = "Year and Month",
y = "Attendance",
color = "Data Type") +
scale_color_manual(values = c("Historical" = "blue", "Forecast" = "red"))
combined_data_rc
View(combined_data_rc)
combined_data_rc <- combined_data_rc %>%
mutate(data_type = if_else(YearMonth < ymd("2023-06-01"), "Historical", "Forecast"))
# Plotting
ggplot(combined_data_rc, aes(x = YearMonth, y = attendance, color = data_type)) +
geom_line() +
facet_wrap(~Aggregated_Organisation, scales = "free_y") +
theme_minimal() +
labs(title = "Attendance Over Time",
subtitle = "Distinguishing between historical and forecasted data",
x = "Year and Month",
y = "Attendance",
color = "Data Type") +
scale_color_manual(values = c("Historical" = "blue", "Forecast" = "red"))
forecast_6months <- combined_data_rc %>%
filter(data_type == "Forecast")
View(forecast_6months)
# hierarchy with age group
data_hts2 <- data_grouped_age |>
aggregate_key(Aggregated_Organisation / Hospital_ItemName_ENG, attendance = sum(Data))
data_hts2 <- data_hts2 %>%
as_tsibble(key = c("Aggregated_Organisation", "Hospital_ItemName_ENG"), index = "YearMonth")
library(fable.tscount)
library(tscount)
# Split data
training_data2 <- data_hts2 %>%
filter(YearMonth <= yearmonth("2020 Jun"))
test_data2 <- data_hts2 %>%
filter(YearMonth > yearmonth("2020 Jun"))
test_data_filtered2 <- test_data2 %>%
filter(Aggregated_Organisation == "<aggregated>")
tscv2 <- training_data2 %>%
stretch_tsibble(.init = 98, .step = 1)
tscv2 <- training_data2 %>%
stretch_tsibble(.init = 98, .step = 1)
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
fig.pos = "H", out.extra = "")
options(tinytex.verbose = TRUE)
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
library(purrr)
library(tidyr)
library(stats)
library(fable)
library(dplyr)
library(igraph)
library(ggraph)
library(feasts)
data <- read.csv("HLTH0037_ts_cleaned.csv")
# change data structure
data <- data %>%
mutate(YearMonth = yearmonth(YearMonth)) %>%
as_tsibble(index = YearMonth, key = c(Age_Code, Sex_ItemName_ENG, Hospital_Code, Hospital_ItemName_ENG))
# Aggregate the data
data_hts <- data %>%
aggregate_key(Organisation/Hospital_ItemName_ENG, attendance = sum(Data))
# Plot the aggregated data
data_hts |>
filter(is_aggregated(Hospital_ItemName_ENG)) |>
autoplot(attendance) +
labs(y = "Number of patients",
title = "Number of patients who enter ED") +
facet_wrap(vars(Organisation), scales = "free_y", ncol = 3) +
theme(legend.position = "none")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
# mutate Aggregated_Organisation due to the change of the health boards
data_grouped <- data %>%
mutate(Aggregated_Organisation = case_when(
Organisation %in% c("Cwm Taf", "Cwm Taf Morgannwg", "Abertawe Bro Morgannwg", "Swansea Bay") ~ "Grouped_4_organisation",
TRUE ~ Organisation
))
unique(data_grouped$Aggregated_Organisation)
data2_hts <- data_grouped %>%
group_by(Aggregated_Organisation) %>%
summarise(attendance = sum(Data))
data2_hts |>
ggplot(aes(x = YearMonth, y = attendance)) +
geom_line(stat = "identity") +
labs(y = "Number of patients",
title = "Number of patients who enter ED") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y", ncol = 3) +
theme(legend.position = "none") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
data_grouped |>
group_by(Aggregated_Organisation) |>
summarise(`Number of patients` = sum(Data)) |>
gg_season() +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y", nrow = 3)+
theme(legend.position = "bottom",
axis.text.x = element_text(angle = 45, hjust = 1)) +
labs(title = "Seasonal plots of ED Attendances (by LHB)")
# Decompose time series for each health board using STL
stl_decompositions <- data2_hts %>%
split(.$Aggregated_Organisation) %>%
purrr::map(function(data){
ts_data <- ts(data$attendance, frequency = 12)
stl(ts_data, s.window = "periodic")
})
# Convert the decompositions to a tidy data frame
stl_df <- purrr::map2_dfr(stl_decompositions, names(stl_decompositions),
~{
time_series <- as.data.frame(.x$time.series)
time_series$Aggregated_Organisation <- .y
return(time_series)
})
num_months <- length(unique(data2_hts$YearMonth))
num_orgs <- length(unique(data2_hts$Aggregated_Organisation))
# Correct assignment for YearMonth column
stl_df$YearMonth <- rep(unique(data2_hts$YearMonth), times = num_orgs)
stl_df_tidy <- stl_df %>%
tidyr::pivot_longer(cols = c(trend, seasonal, remainder),
names_to = "component",
values_to = "value")
stl_df_tidy %>%
ggplot(aes(x = YearMonth, y = value, color = component)) +
geom_line() +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y", ncol = 3) +
labs(title = "STL Decomposition of ED Attendance",
y = "Number of Patients",
color = "Component") +
scale_color_manual(values = c("blue", "green", "red"),
breaks = c("trend", "seasonal", "remainder"),
labels = c("Trend", "Seasonal", "Residual")) +
theme(legend.position = "bottom",
axis.text.x = element_text(angle = 45, hjust = 1))
unique(data_grouped$Age_Code)
data_grouped_age <- data_grouped %>%
filter(Age_Code != "Unknown") %>%
mutate(Grouped_Age = case_when(
Age_Code == "0 to 4" ~ "0-4",
Age_Code == "5 to 17" ~ "5-17",
Age_Code %in% c("18 to 24", "25 to 29", "30 to 34", "35 to 39",
"40 to 44", "45 to 49", "50 to 54", "55 to 59",
"60 to 64", "65 to 69") ~ "18-69",
Age_Code %in% c("70 to 74", "75 to 79", "80 to 84", "85") ~ "70 and over",
TRUE ~ "Other"
))
data_gts <- data_grouped_age %>%
filter(Sex_ItemName_ENG != "Not Specified or invalid") %>%
group_by(Grouped_Age, Sex_ItemName_ENG) %>%
summarize(Number = sum(Data, na.rm = TRUE))
ggplot(data_gts, aes(x = Grouped_Age, y = Number)) +
geom_bar(stat = "identity") +
labs(y = "Number of patients") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
facet_wrap(~ Sex_ItemName_ENG, scales = "free")
#Change the data into wide format
data2_wide <- data_grouped %>%
group_by(Aggregated_Organisation) %>%
index_by(YearMonth) %>%
summarise(attendance = sum(Data)) %>%
pivot_wider(names_from = Aggregated_Organisation, values_from = attendance)
data2_wide <- as_tibble(data2_wide)
data2_wide <- data2_wide %>%
mutate(Total = rowSums(select(., c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching")), na.rm = TRUE))
# Define the forecast horizon and validation period
h <- 12
validation_period <- 6
# Splitting the data into training and testing sets
training_data <- head(data2_wide, nrow(data2_wide) - validation_period)
test_data <- tail(data2_wide, validation_period)
cols_to_forecast <- c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching", "Total")
forecast_list <- list()
arima_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
arima_model <- auto.arima(ts_data)
forecast_list[[col]] <- forecast(arima_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
ets_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
ets_model <- ets(ts_data)  # Use the ets function
forecast_list[[col]] <- forecast(ets_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("ETS Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
ets_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (Aggregated_Organisation in cols_to_forecast) {
ts_data <- ts(training_data[[Aggregated_Organisation]], start = c(start_year, start_month), frequency = 12)
ets_model <- ets(ts_data)
forecast_list[[Aggregated_Organisation]] <- forecast(ets_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("ETS Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
# Lists to store forecasts and error metrics
arima_forecast_list <- list()
ets_forecast_list <- list()
arima_error_metrics <- list()
ets_error_metrics <- list()
# Forecasting with ARIMA and ETS
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
# ARIMA model
arima_model <- auto.arima(ts_data)
arima_forecast <- forecast(arima_model, h = h)
arima_forecast_list[[col]] <- arima_forecast
# ETS model
tryCatch({
ets_model <- ets(ts_data)
ets_forecast <- forecast(ets_model, h = h)
ets_forecast_list[[col]] <- ets_forecast
}, error = function(e) {
cat("Error in forecasting for column:", col, "with message:", e$message, "\n")
})
}
for (col in cols_to_forecast) {
actual <- test_data[[col]]
arima_forecasted <- head(arima_forecast_list[[col]]$mean, validation_period)
# ARIMA metrics
arima_MAE <- mae(actual, arima_forecasted)
arima_RMSE <- rmse(actual, arima_forecasted)
arima_MAPE <- tryCatch(mape(actual, arima_forecasted), error = function(e) NA)
arima_error_metrics[[col]] <- list(MAE = arima_MAE, RMSE = arima_RMSE, MAPE = arima_MAPE)
# Check if ETS forecast exists for the column to avoid errors
if (!is.null(ets_forecast_list[[col]])) {
ets_forecasted <- head(ets_forecast_list[[col]]$mean, validation_period)
# ETS metrics
ets_MAE <- mae(actual, ets_forecasted)
ets_RMSE <- rmse(actual, ets_forecasted)
ets_MAPE <- tryCatch(mape(actual, ets_forecasted), error = function(e) NA)
ets_error_metrics[[col]] <- list(MAE = ets_MAE, RMSE = ets_RMSE, MAPE = ets_MAPE)
}
}
TableAccuracyMetrics <-
rbind(
# aggregate ARIMA accuracy metrics
as.data.frame(
do.call(rbind,unlist(arima_error_metrics, recursive=FALSE))
) |>
rename(Metric = V1) |>
rownames_to_column("LHB") |>
mutate(
Metric = round(Metric,3),
Model = "ARIMA"
),
# aggregate ETS accuracy metrics
as.data.frame(
do.call(rbind,unlist(ets_error_metrics, recursive=FALSE))
) |>
rename(Metric = V1) |>
rownames_to_column("LHB") |>
mutate(
Metric = round(Metric,3),
Model = "ETS"
)
) |>
## wrangle table from long to wide format
tidyr::pivot_wider(
names_from = Model,
values_from = Metric
)
TableAccuracyMetrics |> knitr::kable()
# hierarchy with age group
data_hts <- data_grouped_age |>
aggregate_key((Aggregated_Organisation / Hospital_ItemName_ENG) * Grouped_Age, attendance = sum(Data))
data_hts <- data_hts %>%
as_tsibble(key = c("Aggregated_Organisation", "Grouped_Age", "Hospital_ItemName_ENG"), index = "YearMonth")
data_hts %>%
group_by(Aggregated_Organisation, Grouped_Age, Hospital_ItemName_ENG) %>%
summarise(n = n()) %>%
arrange(n)
library(fable.tscount)
library(tscount)
# Split data
training_data <- data_hts %>%
filter(YearMonth <= yearmonth("2020 Jun"))
test_data <- data_hts %>%
filter(YearMonth > yearmonth("2020 Jun"))
test_data_filtered <- test_data %>%
filter(Aggregated_Organisation == "<aggregated>")
tscv <- training_data %>%
filter(Aggregated_Organisation == "<aggregated>") %>%
stretch_tsibble(.init = 98, .step = 1)
# Load necessary libraries
library(tsibble)
library(fabletools)
# Set up rolling-origin time series cross-validation
tscv_Aneurin <- data_hts %>%
filter(Aggregated_Organisation == 'Aneurin Bevan') %>%
stretch_tsibble(.init = 31, .step = 1)
tscv_Betsi <- data_hts %>%
filter(Aggregated_Organisation == 'Betsi Cadwaladr') %>%
stretch_tsibble(.init = 31, .step = 1)
fit_model <- data_hts |>
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
)|> mutate (comb = (naive_model+ets_model+tscount)/3)
