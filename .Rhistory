for (level in hierarchy_levels) {
# Extract the ETS model for the current level
ets_model <- fit %>%
filter(Aggregated_Organisation == level) %>%
pull(base)
# Forecast for the current level
forecast_result <- forecast(ets_model, h = "6 months")
# Add the Aggregated_Organisation column as an attribute
attr(forecast_result, "Aggregated_Organisation") <- level
# Store the forecast in the list
forecast_list[[level]] <- forecast_result
}
# Combine the forecasts from the list into a single data frame
combined_forecast <- bind_rows(forecast_list)
library(dplyr)
library(fable)
# Assuming 'fit' and 'data_full' are defined
# Define the hierarchy levels (excluding "<aggregated>")
hierarchy_levels <- c(
"Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale",
"Grouped_4_organisation", "Hywel Dda", "Powys Teaching"
)
# Initialize an empty list to store forecasts for each level
forecast_list <- list()
# Loop through each level of the hierarchy (excluding "<aggregated>")
for (level in hierarchy_levels) {
# Extract the ETS model for the current level
ets_model <- fit %>%
filter(Aggregated_Organisation == level) %>%
pull(base)
# Forecast for the current level
forecast_result <- forecast(ets_model, h = "6 months")
# Store the forecast result as a data frame
forecast_df <- as.data.frame(forecast_result)
# Add the Aggregated_Organisation column
forecast_df$Aggregated_Organisation <- level
# Store the forecast data frame in the list
forecast_list[[level]] <- forecast_df
}
# Combine the forecasts from the list into a single data frame
combined_forecast <- bind_rows(forecast_list)
# Add the top-level aggregation ("<aggregated>") to the combined_forecast
total_forecast <- combined_forecast %>%
group_by(YearMonth) %>%
summarise(value = sum(value)) %>%
mutate(Aggregated_Organisation = "<aggregated>")
combined_forecast
View(combined_forecast)
head(combined_forecast)
view(combined_forecast)
fc <- fit |> forecast(h = "6 months")
# Check for missing values in the data
if (any(is.na(fit))) {
# Handle missing values (impute or remove)
fit <- na.omit(fit)  # Remove rows with missing values as an example
}
# Check for infinite values in the data
if (any(is.infinite(fit))) {
# Handle infinite values
# You may need to investigate the cause of infinite values
}
# Check for missing values in the data
if (any(is.na(fit))) {
# Handle missing values (impute or remove)
fit <- na.omit(fit)  # Remove rows with missing values as an example
}
# Check for infinite values in the 'attendance' column of the list
if (any(sapply(fit$attendance, is.infinite))) {
# Handle infinite values
# You may need to investigate the cause of infinite values
}
# Review and adjust ETS model parameters if necessary
ets_model <- ETS(fit$attendance, error = "A", trend = "N", seasonal = "A")
# Diagnostics (optional)
# You can perform model diagnostics here to assess the model's fit to the data
# Forecast using the ETS model
fc <- forecast(ets_model, h = 6)
summary(fit)
view(fit)
head(fit)
library(dplyr)
library(fable)
# Define the hierarchy levels
hierarchy_levels <- c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching")
# Initialize an empty list to store forecasts
forecast_list <- list()
# Loop through each level of the hierarchy (excluding "<aggregated>")
for (level in hierarchy_levels) {
# Filter the data for the current level
filtered_data <- fit %>%
filter(Aggregated_Organisation == level)
# Create an ETS model for the current level
ets_model <- ETS(filtered_data$base)
# Forecast for the current level
fc <- forecast(ets_model, h = 6)
# Add the Aggregated_Organisation column for the current level
fc <- fc %>%
mutate(Aggregated_Organisation = level)
# Store the forecast in the list
forecast_list[[level]] <- fc
}
fc <- forecast(ets_model, h = 6)
library(dplyr)
library(fable)
# Assuming 'fit' is a valid time series object (tsibble or ts)
# Make sure it has a valid time index (e.g., a column named 'YearMonth')
# Create an ETS model
ets_model <- ETS(fit)
# Forecast for 6 months
fc <- forecast(ets_model, h = 6)
# Assuming you have a data frame or tibble with a time index column 'YearMonth' and a numeric column 'attendance'
# Convert the data frame to a tsibble
library(tsibble)
ts_data <- as_tsibble(data_full, key = Aggregated_Organisation, index = YearMonth)
head(data_full)
# Forecast for 6 months
fc <- fit %>%
forecast(h = 6)
View(data)
# Define a filter date (e.g., "2022 Jun")
filter_date <- yearmonth("2022 Jun")
# Filter your data and fit an ETS model
fit <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
base = ETS(attendance)
)
# Check for missing or infinite values in your data
if (any(is.infinite(fit)) || any(is.na(fit))) {
# Handle missing or infinite values, or investigate their cause
# You can remove problematic rows or impute missing values as needed
# Example: data_full <- data_full %>%
#            filter(!is.infinite(attendance)) %>%
#            mutate(attendance = ifelse(is.na(attendance), 0, attendance))
} else {
# If there are no issues with missing or infinite values, proceed to forecasting
# Forecast for 6 months
fc <- fit %>% forecast(h = 6)
# Check the forecast results or handle errors appropriately
if (!exists("fc")) {
cat("Forecasting failed. Please review your data and model.\n")
} else {
print(fc)
}
}
# Define a filter date (e.g., "2022 Jun")
filter_date <- yearmonth("2022 Jun")
# Filter your data and fit an ETS model
fit <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
base = ETS(attendance)
)
# Check for missing or infinite values in each model
models_have_issues <- any(sapply(fit, function(model) any(is.infinite(model$attendance)) || any(is.na(model$attendance))))
library(purrr)
# Define a filter date (e.g., "2022 Jun")
filter_date <- yearmonth("2022 Jun")
# Filter your data and fit an ETS model
fit <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
base = ETS(attendance)
)
# Check for missing or infinite values in each model
models_have_issues <- any(map_lgl(fit, ~ any(is.infinite(.x$attendance)) || any(is.na(.x$attendance))))
# Check for missing or infinite values in each model
models_have_issues <- any(map_lgl(fit, ~ any(is.infinite(pluck(.x, "attendance"))) || any(is.na(pluck(.x, "attendance")))))
if (models_have_issues) {
# Handle missing or infinite values in models, or investigate their cause
# You can remove problematic models or impute missing values within each model as needed
# Example: fit <- map(fit, ~ {
#             .x$attendance <- ifelse(is.na(.x$attendance), 0, .x$attendance)
#             .x
#           })
} else {
# If there are no issues with missing or infinite values in models, proceed to forecasting
# Forecast for 6 months
fc <- fit %>% forecast(h = 6)
# Check the forecast results or handle errors appropriately
if (!exists("fc")) {
cat("Forecasting failed. Please review your data and model.\n")
} else {
print(fc)
}
}
# Plot the forecast
autoplot(fc)
library(fable)
library(ggplot2)
# Define a list to store individual plots
forecast_plots <- list()
# Loop through each level of the hierarchy (excluding "<aggregated>")
for (level in hierarchy_levels) {
# Filter the forecast results for the current level
level_forecast <- fc %>%
filter(Aggregated_Organisation == level)
# Create a plot for the current level
plot <- autoplot(level_forecast, x = YearMonth, y = value) +
ggtitle(paste("Forecast for", level)) +
xlab("YearMonth") +
ylab("Value")
# Add the plot to the list
forecast_plots[[level]] <- plot
}
# Check for missing or infinite values in each model
models_have_issues <- any(map_lgl(fit, ~ any(is.infinite(pluck(.x, "attendance"))) || any(is.na(pluck(.x, "attendance")))))
if (models_have_issues) {
# Handle missing or infinite values in models, or investigate their cause
# You can remove problematic models or impute missing values within each model as needed
# Example: fit <- map(fit, ~ {
#             .x$attendance <- ifelse(is.na(.x$attendance), 0, .x$attendance)
#             .x
#           })
} else {
# If there are no issues with missing or infinite values in models, proceed to forecasting
# Forecast for 6 months
fc <- fit %>% forecast(h = 12)
# Check the forecast results or handle errors appropriately
if (!exists("fc")) {
cat("Forecasting failed. Please review your data and model.\n")
} else {
print(fc)
}
}
fc |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
data_full ,
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(State), scales = "free_y")
fc |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
data_full ,
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y")
fc |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
data_full ,
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
fc |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
data_full %>% filter(yearmonth(YearMonth) >= "2020 Jan"),
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
# Filter the forecast results for aggregated levels and plot
fc %>%
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) %>%
autoplot(
data_full %>% filter(yearmonth(YearMonth) >= yearmonth("2020 Jan")),
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
fc
View(fc)
library(purrr)
# Define a filter date (e.g., "2022 Jun")
filter_date <- yearmonth("2022 Jun")
# Filter your data and fit an ETS model
fit <- data_full %>%
filter(yearmonth(YearMonth) <= filter_date) %>%
model(
base = ETS(attendance)
)
# Check for missing or infinite values in each model
models_have_issues <- any(map_lgl(fit, ~ any(is.infinite(pluck(.x, "attendance"))) || any(is.na(pluck(.x, "attendance")))))
if (models_have_issues) {
} else {
fc <- fit %>% forecast(h = 18)
# Check the forecast results or handle errors appropriately
if (!exists("fc")) {
cat("Forecasting failed. Please review your data and model.\n")
} else {
print(fc)
}
}
# Filter the forecast results for aggregated levels and plot
fc %>%
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) %>%
autoplot(
data_full %>% filter(yearmonth(YearMonth) >= yearmonth("2020 Jan")),
level = NULL
) +
labs(y = "Attendance ('000)") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,
fig.pos = "H", out.extra = "")
# Required Libraries
library(zoo)
library(ggplot2)
library(lubridate)
library(tsibble)
library(tidyverse)
library(fpp3)
library(hts)
library(dplyr)
library(tidyr)
library(forecast)
library(Metrics)
library(purrr)
library(tidyr)
library(stats)
library(fable)
data <- read.csv("HLTH0037_ts_cleaned.csv")
data <- data %>%
mutate(YearMonth = yearmonth(YearMonth)) %>%
as_tsibble(index = YearMonth, key = c(Age_Code, Sex_ItemName_ENG, Hospital_Code, Hospital_ItemName_ENG))
data_hts <- data %>%
aggregate_key(Organisation/Hospital_ItemName_ENG, Number = sum(Data))
data_hts |>
filter(is_aggregated(Hospital_ItemName_ENG)) |>
autoplot(Number) +
labs(y = "Number of patients",
title = "Number of patients who enter ED") +
facet_wrap(vars(Organisation), scales = "free_y", ncol = 3) +
theme(legend.position = "none")+
theme(axis.text.x = element_text(angle = 45, hjust = 1),
axis.text.y = element_text(angle = 0, hjust = 1))
data_grouped <- data %>%
mutate(Aggregated_Organisation = case_when(
Organisation %in% c("Cwm Taf", "Cwm Taf Morgannwg", "Abertawe Bro Morgannwg", "Swansea Bay") ~ "Grouped_4_organisation",
TRUE ~ Organisation
))
unique(data_grouped$Aggregated_Organisation)
data2_hts <- data_grouped %>%
group_by(Aggregated_Organisation) %>%
summarise(Number = sum(Data))
data2_hts |>
ggplot(aes(x = YearMonth, y = Number)) +
geom_line(stat = "identity") +
labs(y = "Number of patients",
title = "Number of patients who enter ED") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y", ncol = 3) +
theme(legend.position = "none") +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Decompose time series for each health board using STL
stl_decompositions <- data2_hts %>%
split(.$Aggregated_Organisation) %>%
purrr::map(function(data){
ts_data <- ts(data$Number, frequency = 12)
stl(ts_data, s.window = "periodic")
})
# Convert the decompositions to a tidy data frame
stl_df <- purrr::map2_dfr(stl_decompositions, names(stl_decompositions),
~{
time_series <- as.data.frame(.x$time.series)
time_series$Aggregated_Organisation <- .y
return(time_series)
})
num_months <- length(unique(data2_hts$YearMonth))
num_orgs <- length(unique(data2_hts$Aggregated_Organisation))
# Correct assignment for YearMonth column
stl_df$YearMonth <- rep(unique(data2_hts$YearMonth), times = num_orgs)
stl_df_tidy <- stl_df %>%
tidyr::pivot_longer(cols = c(trend, seasonal, remainder),
names_to = "component",
values_to = "value")
stl_df_tidy %>%
ggplot(aes(x = YearMonth, y = value, color = component)) +
geom_line() +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y", ncol = 3) +
labs(title = "STL Decomposition of ED Attendance",
y = "Number of Patients",
color = "Component") +
scale_color_manual(values = c("blue", "green", "red"),
breaks = c("trend", "seasonal", "remainder"),
labels = c("Trend", "Seasonal", "Residual")) +
theme(legend.position = "bottom",
axis.text.x = element_text(angle = 45, hjust = 1))
unique(data_grouped$Age_Code)
data_grouped_age <- data_grouped %>%
filter(Age_Code != "Unknown") %>%
mutate(Grouped_Age = case_when(
Age_Code == "0 to 4" ~ "0-4",
Age_Code == "5 to 17" ~ "5-17",
Age_Code %in% c("18 to 24", "25 to 29", "30 to 34", "35 to 39",
"40 to 44", "45 to 49", "50 to 54", "55 to 59",
"60 to 64", "65 to 69") ~ "18-69",
Age_Code %in% c("70 to 74", "75 to 79", "80 to 84", "85") ~ "70 and over",
TRUE ~ "Other"
))
data_gts <- data_grouped_age %>%
filter(Sex_ItemName_ENG != "Not Specified or invalid") %>%
group_by(Grouped_Age, Sex_ItemName_ENG) %>%
summarize(Number = sum(Data, na.rm = TRUE))
ggplot(data_gts, aes(x = Grouped_Age, y = Number)) +
geom_bar(stat = "identity") +
labs(y = "Number of patients") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
facet_wrap(~ Sex_ItemName_ENG, scales = "free")
#Change the data into wide format
data2_wide <- data_grouped %>%
group_by(Aggregated_Organisation) %>%
index_by(YearMonth) %>%
summarise(Number = sum(Data)) %>%
pivot_wider(names_from = Aggregated_Organisation, values_from = Number)
data2_wide <- as_tibble(data2_wide)
data2_wide <- data2_wide %>%
mutate(Total = rowSums(select(., c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching")), na.rm = TRUE))
h <- 12
validation_period <- 6
training_data <- head(data2_wide, nrow(data2_wide) - validation_period)
test_data <- tail(data2_wide, validation_period)
arima_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
arima_model <- auto.arima(ts_data)
forecast_list[[col]] <- forecast(arima_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
ets_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
ets_model <- ets(ts_data)  # Use the ets function
forecast_list[[col]] <- forecast(ets_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("ETS Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
arima_forecast_list <- list()
ets_forecast_list <- list()
arima_error_metrics <- list()
ets_error_metrics <- list()
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
# ARIMA model
arima_model <- auto.arima(ts_data)
arima_forecast <- forecast(arima_model, h = h)
arima_forecast_list[[col]] <- arima_forecast
# ETS model
tryCatch({
ets_model <- ets(ts_data)
ets_forecast <- forecast(ets_model, h = h)
ets_forecast_list[[col]] <- ets_forecast
}, error = function(e) {
cat("Error in forecasting for column:", col, "with message:", e$message, "\n")
})
}
for (col in cols_to_forecast) {
actual <- test_data[[col]]
arima_forecasted <- head(arima_forecast_list[[col]]$mean, validation_period)
# ARIMA metrics
arima_MAE <- mae(actual, arima_forecasted)
arima_RMSE <- rmse(actual, arima_forecasted)
arima_MAPE <- tryCatch(mape(actual, arima_forecasted), error = function(e) NA)
arima_error_metrics[[col]] <- list(MAE = arima_MAE, RMSE = arima_RMSE, MAPE = arima_MAPE)
# Check if ETS forecast exists for the column to avoid errors
if (!is.null(ets_forecast_list[[col]])) {
ets_forecasted <- head(ets_forecast_list[[col]]$mean, validation_period)
# ETS metrics
ets_MAE <- mae(actual, ets_forecasted)
ets_RMSE <- rmse(actual, ets_forecasted)
ets_MAPE <- tryCatch(mape(actual, ets_forecasted), error = function(e) NA)
ets_error_metrics[[col]] <- list(MAE = ets_MAE, RMSE = ets_RMSE, MAPE = ets_MAPE)
}
}
for (col in cols_to_forecast) {
cat("\nAccuracy metrics for:", col, "\n")
cat("--------------------------\n")
cat("ARIMA:\n")
print(arima_error_metrics[[col]])
cat("ETS:\n")
print(ets_error_metrics[[col]])
cat("\n")
# Add a line break to separate the next set of metrics horizontally
cat("----------------------------------------------------\n")
}
