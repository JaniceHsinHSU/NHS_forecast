))
data_gts <- data_grouped_age %>%
filter(Sex_ItemName_ENG != "Not Specified or invalid") %>%
group_by(Grouped_Age, Sex_ItemName_ENG) %>%
summarize(Number = sum(Data, na.rm = TRUE))
ggplot(data_gts, aes(x = Grouped_Age, y = Number)) +
geom_bar(stat = "identity") +
labs(y = "Number of patients") +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
facet_wrap(~ Sex_ItemName_ENG, scales = "free")
#Change the data into wide format
data2_wide <- data_grouped %>%
group_by(Aggregated_Organisation) %>%
index_by(YearMonth) %>%
summarise(attendance = sum(Data)) %>%
pivot_wider(names_from = Aggregated_Organisation, values_from = attendance)
data2_wide <- as_tibble(data2_wide)
data2_wide <- data2_wide %>%
mutate(Total = rowSums(select(., c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching")), na.rm = TRUE))
# Define the forecast horizon and validation period
h <- 12
validation_period <- 6
# Splitting the data into training and testing sets
training_data <- head(data2_wide, nrow(data2_wide) - validation_period)
test_data <- tail(data2_wide, validation_period)
cols_to_forecast <- c("Aneurin Bevan", "Betsi Cadwaladr", "Cardiff & Vale", "Grouped_4_organisation", "Hywel Dda", "Powys Teaching", "Total")
forecast_list <- list()
arima_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
arima_model <- auto.arima(ts_data)
forecast_list[[col]] <- forecast(arima_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
ets_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
ets_model <- ets(ts_data)  # Use the ets function
forecast_list[[col]] <- forecast(ets_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("ETS Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
ets_forecast_list <- list()
start_year <- year(min(training_data$YearMonth))
start_month <- month(min(training_data$YearMonth))
for (Aggregated_Organisation in cols_to_forecast) {
ts_data <- ts(training_data[[Aggregated_Organisation]], start = c(start_year, start_month), frequency = 12)
ets_model <- ets(ts_data)
forecast_list[[Aggregated_Organisation]] <- forecast(ets_model, h = h)
}
for (col in cols_to_forecast) {
end_year_train <- year(max(training_data$YearMonth))
end_month_train <- month(max(training_data$YearMonth))
start_year_test <- ifelse(end_month_train == 12, end_year_train + 1, end_year_train)
start_month_test <- ifelse(end_month_train == 12, 1, end_month_train + 1)
actual_ts <- ts(test_data[[col]], start = c(start_year_test, start_month_test), frequency = 12)
plot_forecast <- autoplot(forecast_list[[col]]) +
autolayer(actual_ts, series="Actual", PI=FALSE) +
labs(title = paste("ETS Forecast vs Actual for", col)) +
theme(legend.position = "bottom")
print(plot_forecast)
}
# Lists to store forecasts and error metrics
arima_forecast_list <- list()
ets_forecast_list <- list()
arima_error_metrics <- list()
ets_error_metrics <- list()
# Forecasting with ARIMA and ETS
for (col in cols_to_forecast) {
ts_data <- ts(training_data[[col]], start = c(start_year, start_month), frequency = 12)
# ARIMA model
arima_model <- auto.arima(ts_data)
arima_forecast <- forecast(arima_model, h = h)
arima_forecast_list[[col]] <- arima_forecast
# ETS model
tryCatch({
ets_model <- ets(ts_data)
ets_forecast <- forecast(ets_model, h = h)
ets_forecast_list[[col]] <- ets_forecast
}, error = function(e) {
cat("Error in forecasting for column:", col, "with message:", e$message, "\n")
})
}
for (col in cols_to_forecast) {
actual <- test_data[[col]]
arima_forecasted <- head(arima_forecast_list[[col]]$mean, validation_period)
# ARIMA metrics
arima_MAE <- mae(actual, arima_forecasted)
arima_RMSE <- rmse(actual, arima_forecasted)
arima_MAPE <- tryCatch(mape(actual, arima_forecasted), error = function(e) NA)
arima_error_metrics[[col]] <- list(MAE = arima_MAE, RMSE = arima_RMSE, MAPE = arima_MAPE)
# Check if ETS forecast exists for the column to avoid errors
if (!is.null(ets_forecast_list[[col]])) {
ets_forecasted <- head(ets_forecast_list[[col]]$mean, validation_period)
# ETS metrics
ets_MAE <- mae(actual, ets_forecasted)
ets_RMSE <- rmse(actual, ets_forecasted)
ets_MAPE <- tryCatch(mape(actual, ets_forecasted), error = function(e) NA)
ets_error_metrics[[col]] <- list(MAE = ets_MAE, RMSE = ets_RMSE, MAPE = ets_MAPE)
}
}
TableAccuracyMetrics <-
rbind(
# aggregate ARIMA accuracy metrics
as.data.frame(
do.call(rbind,unlist(arima_error_metrics, recursive=FALSE))
) |>
rename(Metric = V1) |>
rownames_to_column("LHB") |>
mutate(
Metric = round(Metric,3),
Model = "ARIMA"
),
# aggregate ETS accuracy metrics
as.data.frame(
do.call(rbind,unlist(ets_error_metrics, recursive=FALSE))
) |>
rename(Metric = V1) |>
rownames_to_column("LHB") |>
mutate(
Metric = round(Metric,3),
Model = "ETS"
)
) |>
## wrangle table from long to wide format
tidyr::pivot_wider(
names_from = Model,
values_from = Metric
)
TableAccuracyMetrics |> knitr::kable()
# hierarchy with age group
data_gts <- data_grouped_age |>
aggregate_key((Aggregated_Organisation / Hospital_ItemName_ENG) * Grouped_Age, attendance = sum(Data))
data_gts <- data_gts %>%
as_tsibble(key = c("Aggregated_Organisation", "Grouped_Age", "Hospital_ItemName_ENG"), index = "YearMonth")
library(dplyr)
# Define the expected number of rows for the entire time series
expected_length <- nrow(unique(data_gts[,"YearMonth"]))
cleaned_data <- data_gts %>%
group_by(Aggregated_Organisation, Grouped_Age, Hospital_ItemName_ENG) %>%
filter(n() == expected_length) %>%
ungroup()
library(fable.tscount)
fit_gts <- cleaned_data %>%
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() + season() , link = "log", model = list(past_obs = 1:12))
)|> mutate (comb = (naive_model+ets_model+tscount)/3)  %>%
reconcile(
bu = bottom_up(comb),
ols = min_trace(comb, method = "ols"),
mint = min_trace(comb, method = "mint_shrink")
)
fc_gts <- fit_gts %>%
forecast(h = 6)
fc_gts |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
cleaned_data,
level = NULL
) +
labs(y = "attendance") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y")+
theme(axis.text.x = element_text(angle = 45, hjust = 1))
fc_gts |>
filter(is_aggregated(Hospital_ItemName_ENG), is_aggregated(Grouped_Age)) |>
autoplot(
cleaned_data %>% filter(YearMonth >= yearmonth("2022 Jan")),
level = NULL
) +
labs(y = "attendance") +
facet_wrap(vars(Aggregated_Organisation), scales = "free_y")+
theme(axis.text.x = element_text(angle = 45, hjust = 1))
library(fable.tscount)
library(tscount)
# Split data
training_data <- cleaned_data %>%
filter(YearMonth <= yearmonth("2022 Jun"))
test_data <- cleaned_data %>%
filter(YearMonth > yearmonth("2022 Jun"))
test_data_filtered <- test_data %>%
filter(Aggregated_Organisation == "<aggregated>")
library(tsibble)
start_date <- min(training_data$YearMonth)
end_date <- max(training_data$YearMonth)
# Calculate the difference in months using yearmonth
number_of_months <- as.integer(yearmonth(end_date) - yearmonth(start_date)) + 1
number_of_months
data_gts_tr <- cleaned_data |>
stretch_tsibble(.init = 123, .step = 1)
filtered_tr <- data_gts_tr %>%
filter(Aggregated_Organisation == "<aggregated>")
data_gts_fc <-filtered_tr |>
model(
naive_model = NAIVE(attendance),
ets_model = ETS(attendance),
tscount = TSCOUNT(attendance ~ trend() + season() , link = "log", model = list(past_obs = 1:12))
)|> mutate (comb = (naive_model+ets_model+tscount)/3) %>%
forecast(h = 12)
view(data_gts_fc)
# Merge the forecasted data with the actual values on the appropriate columns
merged_data <- merge(data_gts_fc, test_data_filtered, by=c("YearMonth", "Aggregated_Organisation", "Grouped_Age", "Hospital_ItemName_ENG"), all.x = TRUE)
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(data_gts_fc, test_data_filtered, by = c("YearMonth"))
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(data_gts_fc, test_data_filtered, by = c("YearMonth")) %>%
as_tibble()
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth"))
View(merged_data)
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_Eng"))
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance - subset_data$.mean) /
(subset_data$attendance - lag(subset_data$attendance))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# Assuming 'test_data_filtered' contains a 'YearMonth' column and an 'attendance_actual' column:
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# After the loops, results_list will have the MASE and RMSSE values for each model for each training dataset
print(results_list)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets
avg_mase <- mean(sapply(model_results, function(x) x$MASE))
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE))
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
print(averaged_results)
print(results_list)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets while removing NA values
avg_mase <- mean(sapply(model_results, function(x) x$MASE), na.rm = TRUE)
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE), na.rm = TRUE)
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
print(averaged_results)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets while removing NA values
avg_mase <- mean(sapply(model_results, function(x) x$MASE), na.rm = TRUE)
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE), na.rm = TRUE)
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
# Convert the averaged_results list to a dataframe
averaged_df <- as.data.frame(do.call(rbind, averaged_results))
# Add a 'model' column to the dataframe
averaged_df$model <- rownames(averaged_df)
# Reorder the columns
averaged_df <- averaged_df[, c("model", "Avg_MASE", "Avg_RMSSE")]
# Reset the row names
rownames(averaged_df) <- NULL
print(averaged_df)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets while removing NA values
avg_mase <- mean(sapply(model_results, function(x) x$MASE), na.rm = TRUE)
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE), na.rm = TRUE)
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
# Convert the averaged_results list to a dataframe
averaged_df <- as.data.frame(do.call(rbind, lapply(averaged_results, function(x) {
list(Avg_MASE = unlist(x$Avg_MASE), Avg_RMSSE = unlist(x$Avg_RMSSE))
})))
# Add a 'model' column to the dataframe
averaged_df$model <- rownames(averaged_df)
# Reorder the columns
averaged_df <- averaged_df[, c("model", "Avg_MASE", "Avg_RMSSE")]
# Reset the row names
rownames(averaged_df) <- NULL
print(averaged_df)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets while removing NA values
avg_mase <- mean(sapply(model_results, function(x) x$MASE), na.rm = TRUE)
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE), na.rm = TRUE)
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
# Convert each list element to a single value
averaged_df$Avg_MASE <- sapply(averaged_df$Avg_MASE, `[[`, 1)
averaged_df$Avg_RMSSE <- sapply(averaged_df$Avg_RMSSE, `[[`, 1)
print(averaged_df)
merged_data <- left_join(as_tibble(data_gts_fc), as_tibble(test_data_filtered), by = c("YearMonth", "Aggregated_Organisation","Grouped_Age", "Hospital_ItemName_ENG"))
# Create an empty list to store results
results_list <- list()
# List of models
model_names <- unique(merged_data$.model)
# List of training datasets (using .id)
training_ids <- unique(merged_data$.id)
# Nested loop: first loop through models, then loop through training datasets
for (model in model_names) {
results_list[[model]] <- list()  # Initialize a nested list for each model
for (id in training_ids) {
# Filter the data for the current model and training dataset
subset_data <- merged_data %>% filter(.model == model & .id == id)
# Calculate MASE and RMSSE
mase_val <- mean(abs((subset_data$attendance.y - subset_data$.mean) /
(subset_data$attendance.y - lag(subset_data$attendance.y))), na.rm = TRUE)
rmsse_val <- sqrt(mean((subset_data$attendance.y - subset_data$.mean)^2, na.rm = TRUE))
# Store results in the nested list
results_list[[model]][[as.character(id)]] <- list(MASE = mase_val, RMSSE = rmsse_val)
}
}
# List to store averaged results
averaged_results <- list()
for (model in model_names) {
# Extract the list of results for the current model
model_results <- results_list[[model]]
# Calculate the average MASE and RMSSE over the 13 training datasets while removing NA values
avg_mase <- mean(sapply(model_results, function(x) x$MASE), na.rm = TRUE)
avg_rmsse <- mean(sapply(model_results, function(x) x$RMSSE), na.rm = TRUE)
# Store the averaged results
averaged_results[[model]] <- list(Avg_MASE = avg_mase, Avg_RMSSE = avg_rmsse)
}
# ... [previous code remains unchanged]
# Convert averaged_results to a dataframe
averaged_df <- data.frame(model = names(averaged_results))
# Extract Avg_MASE and Avg_RMSSE values for each model
averaged_df$Avg_MASE <- sapply(averaged_results, function(x) x$Avg_MASE)
averaged_df$Avg_RMSSE <- sapply(averaged_results, function(x) x$Avg_RMSSE)
print(averaged_df)
